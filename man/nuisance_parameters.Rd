% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nuisance_parameters.R
\name{nuisance_parameters}
\alias{nuisance_parameters}
\title{Nuisance Parameter Estimation}
\usage{
nuisance_parameters(
  NuPa = c("Y.hat", "Y.hat.d", "Y.hat.z", "D.hat", "D.hat.z", "Z.hat"),
  X,
  Y = NULL,
  D = NULL,
  Z = NULL,
  methods,
  stacking,
  cluster = NULL,
  stratify = FALSE,
  cf,
  cf_mat = NULL,
  ensemble_type = "nnls",
  store_models = c("no", "memory", "disk"),
  path = NULL,
  quiet = TRUE
)
}
\arguments{
\item{NuPa}{Character vector specifying the nuisance parameters to estimate.
Currently supported options:
\code{c("Y.hat", "Y.hat.d", "Y.hat.z", "D.hat", "D.hat.z", "Z.hat")}}

\item{X}{A numeric matrix of covariates, with rows as observations and columns as covariates; no intercept included.}

\item{Y}{A numeric vector indicating the outcome variable.}

\item{D}{A numeric vector indicating the treatment variable.}

\item{Z}{A numeric vector indicating the instrumental variable.}

\item{methods}{List of methods to use for \code{\link{ensemble}} estimation.
Methods can be created using \code{\link{create_method}}.}

\item{stacking}{Stacking option: Either "short" for short stacking or an integer >1
indicating the number of cross-validation folds within each
cross-fitting fold.}

\item{cluster}{Optional vector of cluster variables if cross-fitting should
account for clusters within the data.}

\item{stratify}{Logical. If \code{TRUE}, cross-fitting folds will preserve the
treatment ratios from the full sample. Note: If cluster vector
is provided, stratification is ignored due to computational
constraints and randomization feasibility issues.}

\item{cf}{Number of cross-fitting folds}

\item{cf_mat}{Optional logical matrix of indicators representing the different
cross-fitting folds, possibly from already estimated \code{NuisanceParameters} object.}

\item{ensemble_type}{Method for calculating ensemble weights:
\describe{
  \item{\code{"nnls"}}{Non-negative least squares; weights sum to 1 (default)}
  \item{\code{"bfgs"}}{BFGS optimization (for multivalued treatments only; falls to \code{nnls} otherwise)}
  \item{\code{"singlebest"}}{Weight of 1 on the learner with the lowest RMSE}
  \item{\code{"ols"}}{Ordinary least squares regression weights (falls to \code{nnls} for multivalued treatments)}
  \item{\code{"average"}}{Equal weights for all learners}
}}

\item{store_models}{Character vector indicating whether to save individual
models for future processing (default: "no").
Supported options: \code{c("no", "memory", "disk")}}

\item{path}{Optional path to save the \code{\link{ensemble}} objects for
later processing (saved as a list of models).}

\item{quiet}{Logical. If \code{FALSE}, progress output is printed to the console.}
}
\value{
A list containing:
\itemize{
  \item \code{nuisance_parameters}: Requested nuisance parameter estimates
  \item \code{models} (optional): \code{\link{ensemble}} objects (individual models)
  \item \code{numbers}: Additional objects used for downstream processing in
                        smoother matrices and outcome weights extraction
}
}
\description{
Estimates nuisance parameters using ensemble methods.
}
\examples{
\donttest{
  if (requireNamespace("hdm", quietly = TRUE)) {
    data(pension, package = "hdm")
    
    set.seed(123)
    D <- pension$p401
    Y <- pension$net_tfa
    X <- model.matrix(~ 0 + age + db + educ + fsize + hown + inc + male + 
                      marr + pira + twoearn, data = pension)
    
    methods = list(
      "ols" = create_method("ols"),
      "forest_grf" = create_method("forest_grf"),
      "xgboost" = create_method("xgboost")
    )
    
    np <- nuisance_parameters(
      NuPa = c("Y.hat", "D.hat"),
      X = X, Y = Y, D = D,
      methods = methods, cf = 2, stacking = "short"
    )
    
    print(head(np$nuisance_parameters[["Y.hat"]]))
    plot(np$numbers$ens_weights)
  }
}

}
