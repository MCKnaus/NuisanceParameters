% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nuisance_parameters.R
\name{nuisance_parameters}
\alias{nuisance_parameters}
\title{Nuisance Parameter Estimation}
\usage{
nuisance_parameters(
  NuPa = c("Y.hat", "Y.hat.d", "Y.hat.z", "D.hat", "D.hat.z", "Z.hat"),
  X,
  Y = NULL,
  D = NULL,
  Z = NULL,
  methods,
  stacking,
  cluster = NULL,
  stratify = FALSE,
  cf,
  cf_mat = NULL,
  do_bfgs = FALSE,
  storeModels = c("No", "Memory", "Disk"),
  tuneLearners = NULL,
  path = NULL,
  quiet = TRUE
)
}
\arguments{
\item{NuPa}{Character vector specifying the nuisance parameters to estimate.
Currently supported options:
\code{c("Y.hat", "Y.hat.d", "Y.hat.z", "D.hat", "D.hat.z", "Z.hat")}}

\item{X}{A numeric matrix of covariates, with rows as observations and columns as covariates.}

\item{Y}{A numeric vector indicating the outcome variable}

\item{D}{A numeric vector indicating the treatment variable}

\item{Z}{A numeric vector indicating the instrumental variable.}

\item{methods}{List of methods to use for \code{\link{ensemble}} estimation.
Methods can be created using \code{\link{create_method}}.}

\item{stacking}{Stacking option: Either "short" for short stacking or an integer >1
indicating the number of cross-validation folds within each
cross-fitting fold.}

\item{cluster}{Optional vector of cluster variables if cross-fitting should
account for clusters within the data.}

\item{stratify}{Logical. If \code{TRUE}, cross-fitting folds will preserve the
treatment ratios from the full sample. Note: If cluster vector
is provided, stratification is ignored due to computational
constraints and randomization feasibility issues.}

\item{cf}{Number of cross-fitting folds (default: 5).}

\item{cf_mat}{Optional logical matrix of indicators representing the different
cross-fitting folds, possibly from already estimated \code{NuisanceParameters} object.}

\item{do_bfgs}{Logical. If \code{TRUE} and the treatment is multinomial,
estimates ensemble weights by BFGS optimization with a softmax 
constraint. If \code{FALSE}, estimates weights via stacked NNLS 
from the \code{nnls} package.}

\item{storeModels}{Character vector indicating whether to save individual
models for future processing (default: "No").
Supported options: \code{c("No", "Memory", "Disk")}}

\item{tuneLearners}{Optional hyperparameter tuning for selected learners (see \code{\link{create_method}} 
                  for details). Either \code{NULL} (default) for no tuning, or one of:
\describe{
  \item{\code{"full_sample" }}{Tune hyperparameters using full sample.}
  \item{\code{"fold" }}{Tuning is performed on the estimation part of the 
                       cross-fitting split, which is roughly
                       \eqn{F} times more computationally demanding.}
}}

\item{path}{Optional path to save the \code{\link{ensemble}} objects for
later processing (saved as a list of models).}

\item{quiet}{Logical. If \code{FALSE}, progress output is printed to the console.}
}
\value{
A list containing:
\itemize{
  \item \code{nuisance_parameters}: Requested nuisance parameter estimates
  \item \code{models} (optional): \code{\link{ensemble}} objects (individual models)
  \item \code{numbers}: Additional objects used for downstream processing in
                        smoother matrices and outcome weights extraction
}
}
\description{
Estimates nuisance parameters using ensemble methods.
}
\examples{
\donttest{
  if (requireNamespace("hdm", quietly = TRUE)) {
    data(pension, package = "hdm")
    
    set.seed(123)
    D <- pension$p401
    Y <- pension$net_tfa
    X <- model.matrix(~ 0 + age + db + educ + fsize + hown + inc + male + 
                      marr + pira + twoearn, data = pension)
    
    methods = list(
      "ols" = create_method("ols"),
      "forest_grf" = create_method("forest_grf"),
      "xgboost" = create_method("xgboost")
    )
    
    np <- nuisance_parameters(
      NuPa = c("Y.hat", "D.hat"),
      X = X, Y = Y, D = D,
      methods = methods, cf = 2, stacking = "short"
    )
    
    print(head(np$nuisance_parameters[["Y.hat"]]))
    plot(np$numbers$ens_weights)
  }
}

}
